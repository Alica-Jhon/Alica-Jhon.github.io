<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Java学习笔记总结"><meta name="description" content=""><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><script async src="https://www.googletagmanager.com/gtag/js?id="></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","")</script><title>Java基础知识学习笔记总结 | 圆宝の博客</title><link rel="icon" type="image/png" href="/medias/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><style lang="css">#loading-container{position:fixed;top:0;left:0;min-height:100vh;width:100vw;z-index:9999;display:flex;flex-direction:column;justify-content:center;align-items:center;background:#fff;text-align:center;-webkit-transition:opacity 1s ease;-moz-transition:opacity 1s ease;-o-transition:opacity 1s ease;transition:opacity 1s ease}.loading-image{width:120px;height:50px;transform:translate(-50%)}.loading-image div:nth-child(2){-webkit-animation:pacman-balls 1s linear 0s infinite;animation:pacman-balls 1s linear 0s infinite}.loading-image div:nth-child(3){-webkit-animation:pacman-balls 1s linear .33s infinite;animation:pacman-balls 1s linear .33s infinite}.loading-image div:nth-child(4){-webkit-animation:pacman-balls 1s linear .66s infinite;animation:pacman-balls 1s linear .66s infinite}.loading-image div:nth-child(5){-webkit-animation:pacman-balls 1s linear .99s infinite;animation:pacman-balls 1s linear .99s infinite}.loading-image div:first-of-type{width:0;height:0;border:25px solid #49b1f5;border-right-color:transparent;border-radius:25px;-webkit-animation:rotate_pacman_half_up .5s 0s infinite;animation:rotate_pacman_half_up .5s 0s infinite}.loading-image div:nth-child(2){width:0;height:0;border:25px solid #49b1f5;border-right-color:transparent;border-radius:25px;-webkit-animation:rotate_pacman_half_down .5s 0s infinite;animation:rotate_pacman_half_down .5s 0s infinite;margin-top:-50px}@-webkit-keyframes rotate_pacman_half_up{0%{transform:rotate(270deg)}50%{transform:rotate(1turn)}to{transform:rotate(270deg)}}@keyframes rotate_pacman_half_up{0%{transform:rotate(270deg)}50%{transform:rotate(1turn)}to{transform:rotate(270deg)}}@-webkit-keyframes rotate_pacman_half_down{0%{transform:rotate(90deg)}50%{transform:rotate(0)}to{transform:rotate(90deg)}}@keyframes rotate_pacman_half_down{0%{transform:rotate(90deg)}50%{transform:rotate(0)}to{transform:rotate(90deg)}}@-webkit-keyframes pacman-balls{75%{opacity:.7}to{transform:translate(-100px,-6.25px)}}@keyframes pacman-balls{75%{opacity:.7}to{transform:translate(-100px,-6.25px)}}.loading-image div:nth-child(3),.loading-image div:nth-child(4),.loading-image div:nth-child(5),.loading-image div:nth-child(6){background-color:#49b1f5;width:15px;height:15px;border-radius:100%;margin:2px;width:10px;height:10px;position:absolute;transform:translateY(-6.25px);top:25px;left:100px}.loading-text{margin-bottom:20vh;text-align:center;color:#2c3e50;font-size:2rem;box-sizing:border-box;padding:0 10px;text-shadow:0 2px 10px rgba(0,0,0,.2)}@media only screen and (max-width:500px){.loading-text{font-size:1.5rem}}.fadeout{opacity:0}@-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}@keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0)}}</style><script>setTimeout(function(){const e=document.getElementById("loading-container");e.className="fadeout",setTimeout(function(){e.style.display="none"},1e3)},1e3)</script><meta name="generator" content="Hexo 5.4.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="圆宝の博客" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><div id="loading-container"><p class="loading-text">玩命加载中 . . .</p><div class="loading-image"><div></div><div></div><div></div><div></div><div></div></div></div><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">圆宝の博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/galleries" class="waves-effect waves-light"><i class="far fa-images" style="zoom:.6"></i> <span>相册</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>时光轴</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于我</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/navigate" class="waves-effect waves-light"><i class="fas fa-location-arrow" style="zoom:.6"></i> <span>快速导航</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">圆宝の博客</div><div class="logo-desc">无限可能<i class="fas fa-heart"></i>未来可期</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/galleries" class="waves-effect waves-light"><i class="fa-fw far fa-images"></i> 相册</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 时光轴</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于我</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li class="m-nav-item"><a href="/navigate" class="waves-effect waves-light"><i class="fa-fw fas fa-location-arrow"></i> 快速导航</a></li><li><div class="divider"></div></li><li><a href="https://github.com/Alica-Jhon" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#ee1289;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/Alica-Jhon" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><script src="/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/7.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Java基础知识学习笔记总结</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px;background-color:rgb(255,255,255,.7);border-radius:10px;box-shadow:0 10px 35px 2px rgba(0,0,0,.15),0 5px 15px rgba(0,0,0,.07),0 2px 5px -5px rgba(0,0,0,.1)!important}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/java/"><span class="chip bg-color">java</span> </a><a href="/tags/%E6%A0%88/"><span class="chip bg-color">栈</span> </a><a href="/tags/%E5%AF%B9%E8%B1%A1/"><span class="chip bg-color">对象</span> </a><a href="/tags/%E5%86%85%E5%AD%98/"><span class="chip bg-color">内存</span> </a><a href="/tags/string/"><span class="chip bg-color">string</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/java/" class="post-category">java</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2021-04-19</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 12.8k</div></div></div><hr class="clearfix"><link rel="stylesheet" href="/libs/prism/prism.css"><div class="card-content article-card-content"><div id="articleContent"><h2 id="java基础复习"><a href="#java基础复习" class="headerlink" title="java基础复习"></a>java基础复习</h2><h3 id="1、-抽象类可以有构造器，可以有一个非抽象的父类"><a href="#1、-抽象类可以有构造器，可以有一个非抽象的父类" class="headerlink" title="1、 抽象类可以有构造器，可以有一个非抽象的父类"></a>1、 抽象类可以有构造器，可以有一个非抽象的父类</h3><h3 id="2、-垃圾回收机制回收的是堆里面的内存，栈里面的数据自动入栈自动出栈"><a href="#2、-垃圾回收机制回收的是堆里面的内存，栈里面的数据自动入栈自动出栈" class="headerlink" title="2、 垃圾回收机制回收的是堆里面的内存，栈里面的数据自动入栈自动出栈"></a>2、 垃圾回收机制回收的是堆里面的内存，栈里面的数据自动入栈自动出栈</h3><h3 id="3、-引用类型的数据在堆当中，内存中操作的只有栈，new关键字在堆里面分配一块内存"><a href="#3、-引用类型的数据在堆当中，内存中操作的只有栈，new关键字在堆里面分配一块内存" class="headerlink" title="3、 引用类型的数据在堆当中，内存中操作的只有栈，new关键字在堆里面分配一块内存"></a>3、 引用类型的数据在堆当中，内存中操作的只有栈，new关键字在堆里面分配一块内存</h3><h3 id="4、-java中是值传递"><a href="#4、-java中是值传递" class="headerlink" title="4、 java中是值传递"></a>4、 java中是值传递</h3><h3 id="5、-String是不可变字符，即一旦分配了内存，此内存的值将不会改变，又将String赋值是，会重新分配一块内存，字符串池：-StringBuffer"><a href="#5、-String是不可变字符，即一旦分配了内存，此内存的值将不会改变，又将String赋值是，会重新分配一块内存，字符串池：-StringBuffer" class="headerlink" title="5、 String是不可变字符，即一旦分配了内存，此内存的值将不会改变，又将String赋值是，会重新分配一块内存，字符串池： StringBuffer"></a>5、 String是不可变字符，即一旦分配了内存，此内存的值将不会改变，又将String赋值是，会重新分配一块内存，字符串池： StringBuffer</h3><h3 id="6、-在堆中的东西叫对象"><a href="#6、-在堆中的东西叫对象" class="headerlink" title="6、 在堆中的东西叫对象"></a>6、 在堆中的东西叫对象</h3><h4 id="运行时异常："><a href="#运行时异常：" class="headerlink" title="运行时异常："></a>运行时异常：</h4><p>&nbsp; &nbsp; ArithmeticException&nbsp; 当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</p><p>&nbsp; &nbsp;ArrayIndexOutOfBoundsException用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</p><p>&nbsp; &nbsp;ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。如：</p><p>&nbsp; &nbsp;Objectx[] = new String[3];</p><p>&nbsp; &nbsp;x[0]= new Integer(0);</p><p>&nbsp; &nbsp;ClassCastException视图将对象转换为不是实例的子类时，抛出该异常。如：</p><p>&nbsp; &nbsp;Objectx = new Integer(0);</p><p>&nbsp; &nbsp;System.out.println((String)x);</p><p>&nbsp; &nbsp;illegalArgumentException表明向方法传递了一个不合法或不正确的参数</p><p>&nbsp; &nbsp;NegativeArraySizeException如果应用程序视图创建大小为负的数组，则抛出该异常</p><h4 id="编译时异常："><a href="#编译时异常：" class="headerlink" title="编译时异常："></a>编译时异常：</h4><p>&nbsp; &nbsp;NoSuchMethodException无法找到某一特定方法时，抛出该异常</p><h3 id="7、-unicode码范围"><a href="#7、-unicode码范围" class="headerlink" title="7、 unicode码范围"></a>7、 unicode码范围</h3><p>&nbsp; 汉字：[\u4e00,\u9fa5]</p><p>&nbsp; 数字：[0x30,0x39]</p><p>&nbsp; 小写字母：[0x61,0x7a]</p><p>&nbsp; 大写字母：[0x41,0x5a]</p><h3 id="8、-final类"><a href="#8、-final类" class="headerlink" title="8、 final类"></a>8、 final类</h3><p>&nbsp; &nbsp;final类能够修饰非抽象类、非抽象类成员方法和变量（静态变量、实例变量、局部变量）</p><p>&nbsp; &nbsp;final类不能被继承，没有子类</p><p>&nbsp; &nbsp;final方法可以被继承，但不能被子类的方法覆盖</p><p>&nbsp; &nbsp;final成员变量表示常量，声明成员变量时，必须赋值（要么在声明的时候赋值，要么在构造器中赋值），赋值后不能被改变</p><p>&nbsp; &nbsp;publicfinalint E; //final空白,必须在初始化对象的时候赋初值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Test3(int x) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E= x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp; &nbsp;final不能用于修饰构造方法2.5</p><h3 id="9、-static只能修饰成员变量，表示所有对象共享这个数据"><a href="#9、-static只能修饰成员变量，表示所有对象共享这个数据" class="headerlink" title="9、 static只能修饰成员变量，表示所有对象共享这个数据"></a>9、 static只能修饰成员变量，表示所有对象共享这个数据</h3><p>&nbsp; &nbsp;static能够修饰成员变量和方法，内部类，也可以形成静态static代码块，不能修饰局部变量</p><p>&nbsp; &nbsp;被static修饰的成员变量可以直接用类名来调用，语法如下：</p><p>&nbsp; &nbsp;类名.静态放大名（）；</p><p>&nbsp; &nbsp;类名.静态变量名；</p><p>&nbsp; &nbsp;静态方法中不能用this和super关键字，不能直接访问不带static的成员变量和成员方法</p><p>&nbsp; &nbsp;因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract</p><p>&nbsp; &nbsp;先运行静态代码块，再运行构造器</p><p>&nbsp;</p><h3 id="10、static和final一块表示什么"><a href="#10、static和final一块表示什么" class="headerlink" title="10、static和final一块表示什么"></a>10、static和final一块表示什么</h3><p>&nbsp; &nbsp;staticfinal用来修饰成员变量和成员方法，可理解为全局变量（java中没有全局变量的概念）</p><p>&nbsp; &nbsp;staticfinal修饰变量，表示一旦给值就不可修改，并且通过类名就可以访问</p><p>&nbsp; &nbsp;staticfinal修饰方法，表示不可覆盖，并可通过类名直接访问&nbsp;</p><p>&nbsp; &nbsp;staticfinal修饰一些容器类型（ArrayList、HashMap）的变量，不可以改变容器变量本省，但可以修改容器中存放的对象</p><p>&nbsp;</p><h3 id="11、类成员变量分类"><a href="#11、类成员变量分类" class="headerlink" title="11、类成员变量分类"></a>11、类成员变量分类</h3><p>&nbsp;&nbsp;&nbsp; 被static修饰的变量叫静态变量或者类变量；</p><p>&nbsp;&nbsp;&nbsp; 没有被static修饰的变量叫实例变量。</p><p>&nbsp;</p><h3 id="12、命令行参数"><a href="#12、命令行参数" class="headerlink" title="12、命令行参数"></a>12、命令行参数</h3><p>&nbsp;&nbsp;&nbsp; java主类参数（即命令行参数）</p><p>&nbsp;&nbsp;&nbsp; eclipse中java输入命令行参数，在选定的类中，点击右键run as—Runconfigurations—Arguments-Program arguments-Variables-选择string_prompt</p><p>&nbsp;</p><h3 id="13、Integer-valueOf-String-将字符串转换成Integer包装类"><a href="#13、Integer-valueOf-String-将字符串转换成Integer包装类" class="headerlink" title="13、Integer.valueOf(String)将字符串转换成Integer包装类"></a>13、Integer.valueOf(String)将字符串转换成Integer包装类</h3><p>&nbsp;</p><h3 id="14、一个-java文件中可以有很多类。不过注意以下几点："><a href="#14、一个-java文件中可以有很多类。不过注意以下几点：" class="headerlink" title="14、一个.java文件中可以有很多类。不过注意以下几点："></a>14、一个.java文件中可以有很多类。不过注意以下几点：</h3><h4 id="a、public-权限的类只能有一个（也可以一个都没有，但最多只有1个）"><a href="#a、public-权限的类只能有一个（也可以一个都没有，但最多只有1个）" class="headerlink" title="a、public 权限的类只能有一个（也可以一个都没有，但最多只有1个）"></a>a、public 权限的类只能有一个（也可以一个都没有，但最多只有1个）</h4><h4 id="b、这个-java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）"><a href="#b、这个-java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）" class="headerlink" title="b、这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）"></a>b、这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）</h4><h4 id="c、若这个文件中没有public的类，则文件名随便是一个类的名字即可"><a href="#c、若这个文件中没有public的类，则文件名随便是一个类的名字即可" class="headerlink" title="c、若这个文件中没有public的类，则文件名随便是一个类的名字即可"></a>c、若这个文件中没有public的类，则文件名随便是一个类的名字即可</h4><h4 id="d、用javac-编译这个-java文件的时候，它会给每一个类生成一个-class文件"><a href="#d、用javac-编译这个-java文件的时候，它会给每一个类生成一个-class文件" class="headerlink" title="d、用javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件"></a>d、用javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件</h4><p>&nbsp;</p><h3 id="15、面向对象、面向过程"><a href="#15、面向对象、面向过程" class="headerlink" title="15、面向对象、面向过程"></a>15、面向对象、面向过程</h3><p>&nbsp;&nbsp;&nbsp; 面向对象的三大特性：封装、继承、多态</p><p>&nbsp;&nbsp;&nbsp; 面向过程：C语言的底层语言的特性</p><p>&nbsp;</p><h3 id="16、类和对象："><a href="#16、类和对象：" class="headerlink" title="16、类和对象："></a>16、类和对象：</h3><p>&nbsp;&nbsp;&nbsp; 一个类中可以有多个对象，类是对对象的描述</p><p>&nbsp;&nbsp;&nbsp; 一个类中的成员：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 字段：封装private</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方法：类的行为</p><p>&nbsp; &nbsp; 构造器：与类同名，没有返回值。作用：初始化成员变量。默认构造器：无参且同名没有返回值，当一个类显示的表明构</p><p>造器，则类不自己建立默认构造器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内部类</p><p>&nbsp;</p><h3 id="17、类之间的关系：继承耦合度最高"><a href="#17、类之间的关系：继承耦合度最高" class="headerlink" title="17、类之间的关系：继承耦合度最高"></a>17、类之间的关系：继承耦合度最高</h3><p>&nbsp;&nbsp;&nbsp; A．继承（is-a）: 单继承多实现&nbsp;extends 优点：减少了代码的冗余、缺点：耦合度太高</p><p>&nbsp; &nbsp; B．实现:</p><p>&nbsp;&nbsp;&nbsp; C．组合(has-a):</p><p>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 合成:个体和整体的关系，个体与整体生命周期相同，公司和部门的关系</p><p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 聚合：个体和整体的关系，生命周期不同，学生和学校的关系</p><p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 关联：双向关联</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Class Person{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Petpet;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassPet{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Personowner;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; D．依赖(use-a):一个类作为另一个类方法的参数或者是返回值，称为依赖</p><p>&nbsp;</p><h3 id="18、java设计原则"><a href="#18、java设计原则" class="headerlink" title="18、java设计原则"></a>18、java设计原则</h3><p>低耦合高内聚</p><p>可扩展性和可维护性</p><h3 id="19、继承："><a href="#19、继承：" class="headerlink" title="19、继承："></a>19、继承：</h3><p>&nbsp; 子类中的成员：</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 1）从父类中继承的可视化（非私有的）的成员（字段、方法），不能继承父类的构造器</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 2）子类所特有的成员（字段、方法、构造器）</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 3）重载父类的成员（方法）&nbsp; 多态</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载的条件：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a）发生在同一个类或者父子类之间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b）方法名称相同，参数列表（参数的个数，参数的数据类型、参数的顺序）不同</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c）返回值无所谓</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d）访问权限无所谓</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;歧义重载：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ma(12,34)//歧义重载，编译错误</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicvoid ma(int i,double j){//打印1}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicvoid ma(double i,int j){//打印2}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造器重载：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this.成员（字段、方法）：调用本类的字段、方法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; this(参数列表):调用本类的其他构造方法，必须在构造方法的第一句</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public Person(int age){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this(age,””);//调用下面那个构造器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; publicPerson(int age,String name){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.age= age;//调用本类的字段</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name= name;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;super：父类的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super.成员：调用父类的成员（方法、字段）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(参数列表)：调用父类的构造方法，必须位于子类构造方法的第一句</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果父类中没有无参的构造器，在子类中必须显式的调用父类带参数的构造方法（super（参数类表或者this（参数列表）））；&nbsp; 如果父类有无参的构造器，则子类中可以不用显式调用父类的构造器，因为系统默认调用super（）;</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 4）重写父类的成员（方法）&nbsp; 多态</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重写的条件 ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a）发生在父子类之间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b）方法名称相同，参数列表（参数的个数，参数的数据类型、参数的顺序）相同</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c）返回值必须相同</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d）子类覆盖方法的访问权限大于等于父类被覆盖方法的访问权限</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e）子类不能抛出比父类异常更大的异常（RuntimeException例外）</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 5）隐藏父类的成员（字段）&nbsp;&nbsp;&nbsp;</p><p>多态对象：调用隐藏成员，调用的是父类的</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;调用覆盖成员，调用的是子类的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;</p><h3 id="20、static-类成员"><a href="#20、static-类成员" class="headerlink" title="20、static:类成员"></a>20、static:类成员</h3><p>字段：所有对象共享</p><p>&nbsp;&nbsp;&nbsp; 方法：静态方法不能直接访问非静态的成员，如果需要访问，产生实例访问；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法能够直接访问静态成员和非静态成员</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态方法中不能有this、super关键字</p><p>&nbsp;&nbsp;&nbsp; 块：内存中只执行一次，通常用来初始化静态成员</p><p>&nbsp;&nbsp;&nbsp; 内部类</p><h3 id="21、final：终态的"><a href="#21、final：终态的" class="headerlink" title="21、final：终态的"></a>21、final：终态的</h3><p>&nbsp;&nbsp;&nbsp; 变量：不能第二次赋值，而且必须有初始值</p><p>&nbsp;&nbsp;&nbsp; 方法：不能被重写</p><p>类：不能被继承</p><h3 id="22、abstract："><a href="#22、abstract：" class="headerlink" title="22、abstract："></a>22、abstract：</h3><p>&nbsp;&nbsp; 抽象方法必须在抽象类中，抽象类中不一定要有抽象方法</p><p>&nbsp;&nbsp; 抽象类没有实例</p><p>&nbsp;&nbsp; 抽象类可以有父类，父类可以是抽象类也可以是非抽象类</p><p>&nbsp;&nbsp; 抽象类有构造器，不能用来产生本类实例，构造器用来间接产生子类实例时使用</p><p>&nbsp;&nbsp;abstract不能与static、final、private一起使用</p><h3 id="23、异常处理："><a href="#23、异常处理：" class="headerlink" title="23、异常处理："></a>23、异常处理：</h3><p>&nbsp;&nbsp; 1）try{}catch（）finally{}</p><p>&nbsp;&nbsp; 2）throws&nbsp;&nbsp; 方法声明后 throws 异常类</p><p>&nbsp;&nbsp; 3）throw&nbsp;&nbsp;&nbsp; 句子（通常是if）后throw&nbsp;异常类的实例</p><p>&nbsp;&nbsp; 4）自定义异常类&nbsp; extends&nbsp; Exception或者RuntimeException&nbsp;</p><h3 id="24、方法重写-override-和-重载-overlord-的区别"><a href="#24、方法重写-override-和-重载-overlord-的区别" class="headerlink" title="24、方法重写(override)和 重载(overlord)的区别"></a>24、方法重写(override)和 重载(overlord)的区别</h3><p>重写override：子类中出现与父类中签名相同的方法、访问修饰符要等于高于父类、返回值类型，参数列表都相同</p><p>重载overlord：一个类内部出现两个及两个以上方法名相同、参数列表不同(参数类型，参数个数，参数类型的顺序)的方法</p><p>&nbsp;</p><h3 id="25、动态多态和静态多态"><a href="#25、动态多态和静态多态" class="headerlink" title="25、动态多态和静态多态"></a>25、动态多态和静态多态</h3><p>&nbsp;&nbsp;&nbsp; 动态多态（运行时多态）：运行过程中才知道调用那个方法，指的是方法重写</p><p>&nbsp;&nbsp;&nbsp; 静态多态（编译时多态）：编译时就知道所调用的方法，指的是方法重载</p><p>&nbsp;</p><h3 id="26、如果父类中没有空参构造"><a href="#26、如果父类中没有空参构造" class="headerlink" title="26、如果父类中没有空参构造"></a>26、如果父类中没有空参构造</h3><p>那么子类必须同super()的方式显示的调用父类构造</p><p>建议：如果父类中出现带参构造，那么必须手动添加空参构造</p><p>例：下列代码的运行结果是（&nbsp;B）</p><p>classA{</p><p>&nbsp;&nbsp;&nbsp;&nbsp; public&nbsp; A(int a){System.out.println（“A”）;}</p><p>}</p><p>class B extends A{</p><p>&nbsp;&nbsp;&nbsp; publicB(){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(5);//必须加上这一块，用super（）显示的调用父类中的方法</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; public voidma(){System.out.println(“ma”);}</p><p>}</p><p>public class test{</p><p>&nbsp;&nbsp;&nbsp; public static void main(String[]args){</p><p>B b=new B（）;</p><p>b.ma();</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>A.&nbsp; 打印输出ma</p><p>B.&nbsp; 编译错误</p><p>C.&nbsp; 打印输出A</p><p>D.&nbsp; 打印输出A&nbsp; ma</p><p>&nbsp;</p><h3 id="27、-static："><a href="#27、-static：" class="headerlink" title="27、 static："></a>27、 static：</h3><p>表示静态的，修饰的内容属于类成员；被该类的所有对象共享，建议使用类名.的方式访问；修饰的内容在类加载的时候，执行；只能访问被static修饰的内容；修饰的内容只在类加载的时候执行一次。</p><p>可以修饰的内容：修饰属性、修饰方法、作为代码块使用 jdbc 加载驱动的时候</p><p>&nbsp;&nbsp;&nbsp; static{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(“”);//作为代码块使用</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp; 特点：</p><p>&nbsp;&nbsp;&nbsp; 1.修饰的内容属于类成员</p><p>&nbsp;&nbsp;&nbsp; 2.修饰的方法，不能被重写，可以被重载</p><p>&nbsp;&nbsp;&nbsp; 3.修饰的内容，执行一次</p><p>例：public class HelloWorld{</p><p>public staticvoid main(String args[]){</p><p>method();</p><p>}</p><p>public voidmethod(){</p><p>try{</p><p>System.out.println(“hello我执行”);</p><p>}</p><p>finally{</p><p>System.out.println(“我就不执行”);</p><p>}</p><p>&nbsp; }</p><p>}</p><p>编译运行后，输出结果是什么？(D&nbsp;)</p><p>A.”hello 我执行”</p><p>B.”我就不执行”</p><p>C.”hello 我执行”</p><p>“我就不执行”</p><p>&nbsp; D.代码不能编译</p><p>因为main方法是用static修饰的静态方法，调用的方法也必须用static修饰，而method();方法没有被static修饰</p><p>&nbsp;</p><h3 id="28、hashcode-返回的是对象的内存地址对应的int类型数据，但是我们可以重写hashCode-方法，返回的就不再是内存地址。"><a href="#28、hashcode-返回的是对象的内存地址对应的int类型数据，但是我们可以重写hashCode-方法，返回的就不再是内存地址。" class="headerlink" title="28、hashcode()返回的是对象的内存地址对应的int类型数据，但是我们可以重写hashCode()方法，返回的就不再是内存地址。"></a>28、hashcode()返回的是对象的内存地址对应的int类型数据，但是我们可以重写hashCode()方法，返回的就不再是内存地址。</h3><p>hashcode()相同的对象，这两个对象不一定相同；如果两个对象相同，则hashcode()一定相同。</p><p>&nbsp;</p><h3 id="29、java中的访问修饰符"><a href="#29、java中的访问修饰符" class="headerlink" title="29、java中的访问修饰符"></a>29、java中的访问修饰符</h3><p>public： 所有</p><p>protected： 自己、同一包中、子类可以访问</p><p>default： 默认什么都不加，就是default，自己、同一包中可以访问，但是比protected级别要低即限制更多</p><p>friendly： 自己、同一包中可以访问</p><p>private： 自己</p><p>例：以下代码的运行结果是：(&nbsp;C&nbsp; )</p><ol><li>abstract class abstrctIt {</li></ol><p>2.&nbsp;&nbsp; abstractfloat getFloat ();</p><ol start="3"><li><p>}</p></li><li><p>public class AbstractTest extends AbstractIt {</p></li></ol><p>5.&nbsp;&nbsp; privatefloat f1 = 1.0f;</p><p>6.&nbsp;&nbsp; privatefloat getFloat () {return f1;}</p><ol start="7"><li>}</li></ol><p>A. 编译成功</p><p>B. 第6行产生错误，导致运行失败</p><p>C. 第6行产生错误，导致编译失败</p><p>D. 第5行产生错误，导致编译失败</p><p>默认什么不加的访问修饰符是default，default比private限制少（即更高级），比protected限制多，所有第六行重写方法用的private访问修饰符比父类低级，所有会出现编译失败</p><p>&nbsp;</p><h3 id="30、Math-random-获取-0-1-的值，取不到1；"><a href="#30、Math-random-获取-0-1-的值，取不到1；" class="headerlink" title="30、Math.random()获取[0,1)的值，取不到1；"></a>30、Math.random()获取[0,1)的值，取不到1；</h3><p>用法：（int）Math.random()*n+1;取到1到n之间的整数</p><p>&nbsp;</p><h3 id="31、数组、集合、字符串之间的转换"><a href="#31、数组、集合、字符串之间的转换" class="headerlink" title="31、数组、集合、字符串之间的转换"></a>31、数组、集合、字符串之间的转换</h3><p>a. Arrays.asList() //将数组转换成集合</p><p>例：List list = Arrays.asList(names);//将数组转换成集合。</p><p>b.String.valueOf() //将数组转换成字符串、也可将整数转换成字符串</p><p>例：char []ch1 = {‘a’,’c’,’a’,’b’,’a’};</p><p>&nbsp;&nbsp;&nbsp;&nbsp; String str2 = String.valueOf(ch1);</p><p>例：int num = 123456;</p><p>&nbsp;&nbsp;&nbsp;&nbsp; String str =String.valueOf(num);</p><p>c.toCharArray()将字符串转换成数组</p><p>例：String str = “gdfgdfgd”;</p><p>char[] ch = str.toCharArray();</p><p>&nbsp;&nbsp; d.Arrays.toString()将字符数组变成字符串特定格式输出，如[1,2,3]</p><p>&nbsp;&nbsp;例：String str1 = Arrays.toString(ch);</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(str1);</p><p>&nbsp; &nbsp;e.str.reverse();将字符串反转</p><p>&nbsp;&nbsp; 例：StringBuffersb =new StringBuffer(“adfsdsd”);</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sb.reverse();</p><p>&nbsp;&nbsp; f.</p><h3 id="32、replace-函数"><a href="#32、replace-函数" class="headerlink" title="32、replace();函数"></a>32、replace();函数</h3><p>&nbsp;&nbsp;&nbsp; 例1：//将字符串”abcdabcdabdcadcbadcb”的字符出现的次数输出</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Stringnum = “abcdabcdabdcadcbadcb”;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String t = num.replace(“a”,””);</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(num.length()-t.length());</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; replaceAll()，用正则表达式</p><p>&nbsp;&nbsp;&nbsp; 例2：//将字符串中的数字去除&nbsp;&nbsp;</p><p>String num1 = “ab23c7da45bc5da65bd5c67ad7cb9adcb”;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String t1 = num1.replaceAll(“[0-9]”, “”);</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(t1);</p><p>&nbsp;&nbsp;&nbsp; 例3：//计算字符串的长度，一个字符算两个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; byte[]b =str.getBytes();</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(b.length);//若出现一个汉字代表3个字节的情况，将Utf-8换成GBK就可以了</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String m = str.replaceAll(“[\u4e00-\u9fa5]”, “xx”);</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(m.length());</p><p>&nbsp;</p><h3 id="33、DecimalFormat（）-将数字转换成特定的格式"><a href="#33、DecimalFormat（）-将数字转换成特定的格式" class="headerlink" title="33、DecimalFormat（）;将数字转换成特定的格式"></a>33、DecimalFormat（）;将数字转换成特定的格式</h3><p>例：//数组格式化 int num = 1234567;&nbsp;换成123，4567</p><p>int num = 1234567;</p><p>DecimalFormat f =new DecimalFormat(“#,####”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String t =f.format(num);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(t);</p><p>&nbsp;&nbsp;&nbsp; 例： //将数组转换成123,4567.89的格式</p><p>doubled = 1234567.88898890;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DecimalFormat &nbsp;f =new DecimalFormat(“#,####.##”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(f.format(d));</p><h3 id="34、String类型是否可以被继承，为什么？"><a href="#34、String类型是否可以被继承，为什么？" class="headerlink" title="34、String类型是否可以被继承，为什么？"></a>34、String类型是否可以被继承，为什么？</h3><p>&nbsp;&nbsp;&nbsp; 不能被继承，因为是被final修饰的类</p><p>&nbsp;</p><h3 id="35、String类型是否是基本类型，比较String类型变量时，-和equals有何区别？"><a href="#35、String类型是否是基本类型，比较String类型变量时，-和equals有何区别？" class="headerlink" title="35、String类型是否是基本类型，比较String类型变量时，== 和equals有何区别？"></a>35、String类型是否是基本类型，比较String类型变量时，== 和equals有何区别？</h3><p>&nbsp;&nbsp;&nbsp; 不是，是引用类型</p><p>&nbsp;&nbsp;&nbsp; a.如果 String类型是直接赋值 == 和 equals 效果相同</p><p>&nbsp;&nbsp;&nbsp; &nbsp;String a = “abc “;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;String b = “abc”;</p><p>&nbsp;&nbsp;&nbsp; &nbsp; a ==b 和 a.equals(b)都为true</p><p>&nbsp;&nbsp;&nbsp; b.如果String是通过new构建的 == 和equals效果不同</p><p>&nbsp;&nbsp;&nbsp; &nbsp;String a = new String（“abc”）；</p><p>&nbsp;&nbsp;&nbsp; &nbsp;String b = new String（“abc”）；</p><p>&nbsp;&nbsp;&nbsp; &nbsp; a ==b 结果为false</p><p>&nbsp;&nbsp;&nbsp; &nbsp; a．equals（b）结果为true</p><p>&nbsp;</p><h3 id="36、char类型中是否可以存放一个汉字，为什么？"><a href="#36、char类型中是否可以存放一个汉字，为什么？" class="headerlink" title="36、char类型中是否可以存放一个汉字，为什么？"></a>36、char类型中是否可以存放一个汉字，为什么？</h3><p>&nbsp;&nbsp;&nbsp; 可以，char类型中存放的数据以Unicode码存放。</p><p>&nbsp;</p><h3 id="37、Random-函数"><a href="#37、Random-函数" class="headerlink" title="37、Random()函数"></a>37、Random()函数</h3><p>&nbsp;&nbsp;&nbsp; //获取1-35之间的随机数</p><p>&nbsp;&nbsp;&nbsp; //第一种方法</p><p>Random r = new Random();</p><p>int n = r.nextInt(35)+1;</p><p>//第二种方法Math.random()是取得[0,1)之间的随机小数，取不到1。</p><p>int n =(int) (Math.random()*35+1);</p><p>&nbsp;</p><h2 id="java工具类"><a href="#java工具类" class="headerlink" title="java工具类"></a>java工具类</h2><p>Object：引用类型的根，是所有类的超类，是java中唯一一个没有父类的类</p><h3 id="1、toString-将对象转成字符串"><a href="#1、toString-将对象转成字符串" class="headerlink" title="1、toString():将对象转成字符串"></a>1、toString():将对象转成字符串</h3><h3 id="2、equals（）和-的区别："><a href="#2、equals（）和-的区别：" class="headerlink" title="2、equals（）和==的区别："></a>2、equals（）和==的区别：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; ==：可以判断基本数据类型和引用数据类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引用数据类型，表示两个对象的引用是否相等，即栈里面引用的地址是否相等</p><p>&nbsp;&nbsp;&nbsp;&nbsp; equals：可以判断引用数据类型</p><p>引用数据类型：表示两个对象的引用是否相等，但是包装类、String、Date、File除外（这些判断的是对象的值是否相等，即堆内存里面的值是否相等）</p><p>Stringstr1 = “abc”；</p><p>//创建一个字符串池中的对象，如果里面有此对象了就不再创建了，直接用即可</p><p>Stringstr2 = “abc”；</p><p>Stringstr3 = new String(“abc”)；</p><p>Stringstr4 = new String(“abc”)；</p><p>//可能产生两个或一个对象，在堆内存中首先new出一个对象，再复制到字符串池当中，如果字符串池中有此对象，即不复制。所有堆内存中的对象是肯定存在的，字符串池中的对象不一定</p><p>System.out.println(str1==str2)；true</p><p>System.out.println(str3==str4)；false</p><p>//str3在堆内存中new出一个内存、str4在堆内存中重新new出一个内存，在堆内存中相当于等号的右边。在栈内存中，指向堆内存中的引用值不一样，所有为false</p><p>System.out.println(str1==str3)；false</p><p>//str1是在堆内存中的字符串池里，为“abc”，str3在堆内存new出一个对象‘abc‘占用一块内存，并且复制到字符串池中，如果字符串池中有abc了，即不复制。</p><p>System.out.println(str1.equals(str2));true</p><p>System.out.println(str3.equals(str4));true</p><p>System.out.println(str1.equals(str3));true</p><p>//equals在String类型比较的堆内存的值是否相等，str1字符串池中的内存为abc，str3在堆内存中new出的对象是abc，这两个对象虽然分配的内存不同，但是值相等，所以为true</p><h3 id="3、重写equals方法必须先重写hashcode方法"><a href="#3、重写equals方法必须先重写hashcode方法" class="headerlink" title="3、重写equals方法必须先重写hashcode方法"></a>3、重写equals方法必须先重写hashcode方法</h3><p>相等的对象必须具有相同的哈希码，具有相同哈希码的对象不一定相等</p><h3 id="4、clone（）克隆"><a href="#4、clone（）克隆" class="headerlink" title="4、clone（）克隆"></a>4、clone（）克隆</h3><p>浅表克隆：复制原对象的所有变量的备份,但是引用类型的变量指向原对象的数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 必须实现一个接口implements Cloneable</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 重写Object类的克隆方法clone()</p><p>深表克隆：复制原对象的所有变量的备份，包括引用类型</p><h3 id="5、反射Class-forName-“com-A”"><a href="#5、反射Class-forName-“com-A”" class="headerlink" title="5、反射Class.forName(“com.A”);"></a>5、反射Class.forName(“com.A”);</h3><p>破坏了底层的封装性</p><h3 id="6、包装类"><a href="#6、包装类" class="headerlink" title="6、包装类"></a>6、包装类</h3><p>byteByte</p><p>shortShort</p><p>longLong</p><p>floatFloat</p><p>doubleDouble</p><p>BooleanBoolean</p><p>intIntegar</p><p>charCharacter</p><p>包装类与字符串转换：</p><p>&nbsp;&nbsp;&nbsp;&nbsp; xxxValue（）：转换成其他基本类型</p><p>&nbsp;&nbsp;&nbsp; 包装类-à字符串 toString（）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(i.toString());</p><p>&nbsp;&nbsp;&nbsp; 字符串-à整形 parseXxx（）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i4 =Integer.parseInt(“123”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double i5 =Double.parseDouble(“123.456”);</p><p>装箱和拆箱：JDK1.5只会自动装箱和拆箱</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 装箱：基本数据类型转换为引用数据类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer i5 = 10;</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 拆箱：引用数据类型转换为基本数据类型</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer i5 = 10;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i6 = i5;</p><h3 id="7、String类"><a href="#7、String类" class="headerlink" title="7、String类"></a>7、String类</h3><p>charAt（）方法：一般与for循环一起，遍历字符串</p><p>&nbsp;&nbsp;&nbsp; Stringstr = “Hello Java,Hello World”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0;i&lt;str.length();i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(charAt(i));</p><p>&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>concat()方法;拼接字符串，将指定字符串连接到此字符串的结尾</p><p>&nbsp;&nbsp;&nbsp;&nbsp; str.concat(“s”);&nbsp; //得到Hello Java,Hello Worlds</p><p>startWith()方法;测试此字符串是否已指定的前缀开始，boolean</p><p>&nbsp;&nbsp;&nbsp;&nbsp; str. startWith(“Hello”); //true</p><p>format()方法:将字符串按照某种格式输出</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inti=1;intj=2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(String.format(“%d+%d=%d”,i,j,i+j));//1+2=3</p><p>indexOf(String)方法:输出字符串第一次出现的索引，没有的话输出-1</p><p>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(str.indexOf(“Hello”));//0</p><p>lastIndexOf()方法:输出字符串最后一次出现的索引</p><p>replace(old String, new String)方法:替换字符串</p><p>split()方法:分割字符串</p><p>substring(int start,int end)方法:截取字符串</p><p>toCharArray()方法:变成字符数组</p><p>trim()方法:去掉字符串两端的空格，字符串中间的去不掉</p><p>toUpperCase()方法:将字符串转化为大写</p><p>&nbsp;</p><h3 id="8、StringBuffer和StringBuilder区别"><a href="#8、StringBuffer和StringBuilder区别" class="headerlink" title="8、StringBuffer和StringBuilder区别"></a>8、StringBuffer和StringBuilder区别</h3><p>StringBuffer线程安全的，同步的，效率比较低，JDK1.0之后出现</p><p>StringBuilder线程不安全，不同步的，效率比较高，JDK1.5之后出现</p><p>&nbsp;</p><h3 id="9、StringBuffer方法"><a href="#9、StringBuffer方法" class="headerlink" title="9、StringBuffer方法"></a>9、StringBuffer方法</h3><p>StringBuffersb = new StringBuffer（“aaa”）;</p><p>append 追加字符串</p><p>sb.append(“bb”).append(“bb”);</p><p>delete 删除</p><p>sb.delete(1,2).delete(1,2);</p><p>insert 插入</p><p>sb.insert(1,”22”).insert(1,false);</p><p>setCharAt 修改</p><p>sb.setCharAt(1,’Q’);</p><p>replace 替换</p><p>sb.replace(1,3,”MMM”);</p><p>reverse 反转</p><p>sb.reverse();</p><p>&nbsp;</p><h3 id="9、Math方法"><a href="#9、Math方法" class="headerlink" title="9、Math方法"></a>9、Math方法</h3><p>&nbsp;&nbsp;&nbsp; Math.ceil(2.4);//3取比值大的最小整数</p><p>&nbsp;&nbsp;&nbsp; Math.ceil(-2.4);//-2</p><p>&nbsp;&nbsp;&nbsp; Math.floor(2.5);//2取比值小的最大整数</p><p>&nbsp;&nbsp;&nbsp; Math.round(2.5);//3四舍五入</p><p>&nbsp;&nbsp;&nbsp; Math.round(-2.5);//-2</p><p>&nbsp;&nbsp;&nbsp; Math.random()//范围是[0,1)</p><p>&nbsp;&nbsp;&nbsp; Math.random()*40+60;//取60到99的成绩</p><p>&nbsp;&nbsp;&nbsp; Random方法：范围是[0,1)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Randomran &nbsp;= new Random();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;10;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intscore = ran.nextInt(41)+60;//从60到100</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(score);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><h3 id="10、Date方法"><a href="#10、Date方法" class="headerlink" title="10、Date方法"></a>10、Date方法</h3><p>SimpleDateFormat类：改变时间的格式</p><p>SimpleDateFormatsdf = new SimpleDateFormat(“yyyy/MM/dd HH:mm:ss”);</p><p>Datedate = new Date();</p><p>//将日期格式转换成指定的字符串</p><p>Stringtime = sdf.format(date);</p><p>System.out.println(time);//现在的时间以yyyy/MM/dd HH:mm:ss格式输出</p><p>&nbsp;</p><p>//将格式化的字符串转换成日期对象</p><p>Datedate = sdf.parse(“1995/07/12 03:00:00”);</p><p>System.out.println(date);</p><p>&nbsp;</p><p>TimeZone（）设置时区</p><p>TimeZonetime=TimeZone.getTimeZone(“America/Los_Angeles”);</p><p>&nbsp;&nbsp;&nbsp; Calendar&nbsp;c2=Calendar.getInstance(time,Locale.US);</p><p>&nbsp;&nbsp;&nbsp; Date d=c2.getTime();</p><p>&nbsp;</p><p>GregorianCalendar单独获取年、月、日</p><p>GregorianCalendar gc =newGregorianCalendar(2017,3,5);</p><p>&nbsp;&nbsp;&nbsp; System.out.println(gc.get(Calendar.MONTH));</p><p>&nbsp;</p><p>System.currentTimeMillis();通常用于循环运算的时间</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long startTime = System.currentTimeMillis();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(){}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longendTime = System.currentTimeMillis();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longtime = endTime- startTime//计算出运算的时间</p><p>&nbsp;</p><h2 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h2><h3 id="1、集合和数组的区别："><a href="#1、集合和数组的区别：" class="headerlink" title="1、集合和数组的区别："></a>1、集合和数组的区别：</h3><p>&nbsp;&nbsp;&nbsp; 数组：可以包含基本数据类型或者引用数据类型的对象，数据定长的，访问较快</p><p>&nbsp;&nbsp;&nbsp; 集合：只能包含引用数据类型的对象，不定长。</p><h3 id="2、集合分类："><a href="#2、集合分类：" class="headerlink" title="2、集合分类："></a>2、集合分类：</h3><p>&nbsp;&nbsp;&nbsp; Set:集&nbsp;无序，不重复，父接口为Collection</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add（）;添加元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addAll（Collection）;添加子集合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contains（）;是否包括元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; containsAll（）;是否包含子集合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isEmpty();Boolean判断集合长度是否为0</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove（）;移除元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; removeAll（）;移除一个子集合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size（）;集合的大小</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray（）;将集合转换成数据</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set集合的遍历&nbsp; Iterator 迭代器</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Setset = new HashSet();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iteratorit = set.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Objectobj = it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(obj);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set集合的遍历&nbsp; 增强for循环</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(Object obj:set){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(obj);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet和TreeSet的区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet：内部对象散列存取，顺序和输入的顺序不同</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeSet：元素会进行升序排序（元素是可比较的），顺序和输入的顺序也不同</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; List:列表&nbsp;有序，重复，父接口为Collection</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add（）;添加元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addAll（Collection）;添加子集合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add（key，元素）;插入元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get（key）;获取元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indexOf(元素);返回元素的索引值，如果没有则返回-1</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove(key);移除元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; removeAll（）;移除一个子集合</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set（key,元素）;修改元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; toArray();转换成数组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List集合的遍历&nbsp; 普通for循环</p><p>Listlist = new ArrayList();</p><p>for(inti;i&lt;list.size();i++){</p><p>&nbsp;&nbsp;&nbsp; Object obj = list.get(i);</p><p>&nbsp;&nbsp;&nbsp; System.out.println(obj);</p><p>}</p><p>List集合的遍历&nbsp; 增强for循环</p><p>for(Object obj:list){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(obj);</p><p>}</p><p>List集合的遍历&nbsp; Iterator 迭代器</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Iterator it = list.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Objectobj = it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(obj);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList和LinkedList区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList底层物理存储为线性的（数组的存储方式），查询效率高，删除、添加等操作效率比较低</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LinkedList底层物理存储为链表的，查询效率低，删除、添加效率高</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList和Vector区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两者底层物理存储为线性的</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList：线程不安全，不同步的，数据不安全，效率比较高</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector：线程安全的，同步的，数据安全，效率比较低</p><p>&nbsp;</p><p>Map:字典 键值对存储 key唯一，value可重复</p><p>&nbsp;&nbsp;&nbsp; put(key,values);添加元素</p><p>&nbsp;&nbsp;&nbsp; putAll(map);添加集合</p><p>&nbsp;&nbsp;&nbsp; remove（key）;移除一对元素</p><p>&nbsp;&nbsp;&nbsp; size();集合长度</p><p>&nbsp;&nbsp;&nbsp; containkey(key);是否包含某个键</p><p>&nbsp;&nbsp;&nbsp; containvalue（value）;是否包含某个值</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; Map集合的遍历 keySet()</p><p>&nbsp;&nbsp;&nbsp; Set set = map.keySet();</p><p>&nbsp;&nbsp;&nbsp; Iterator it = set.iterator();</p><p>&nbsp;&nbsp;&nbsp; while(it.hasNext){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object key = it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object value = map.get(key);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(key+”:”+value);</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; Map集合的遍历 entrySet()</p><p>&nbsp;&nbsp;&nbsp; Iterator it = map.entrySet().iterator();</p><p>&nbsp;&nbsp;&nbsp; while(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map.Entry entry = (Map.Entry)it.next();</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.out.println(entry.getKey()+”:”+entry.getValue());</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; HashMap和Hashtable的区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap：键值对允许为null，线程不安全，不同步，效率比较高</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hashtable：键值对不允许为null，线程安全，同步，效率比价低</p><p>&nbsp;&nbsp;&nbsp; HashMap和TreeMap的区别：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap：基于哈希，是无序的</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TreeMap：基于树型结构的，按照键升序排序</p><p>&nbsp;</p><h3 id="3、Collections类："><a href="#3、Collections类：" class="headerlink" title="3、Collections类："></a>3、Collections类：</h3><p>Collections.sort():只针对List集合，集合中的元素必须是可比较的，如果为引用类型，则必须实现Comparator、Compareable（常用）接口</p><p>Collections.shuffle（list）：打乱顺序</p><p>Collections.rotate（list,int i）:根据指定的长度，轮换指定列表中的长度</p><p>Collections.reverse(list):反转集合</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="泛型：数据类型参数化"><a href="#泛型：数据类型参数化" class="headerlink" title="泛型：数据类型参数化"></a>泛型：数据类型参数化</h2><h3 id="1、public-void-arr-T-t1-T-t2"><a href="#1、public-void-arr-T-t1-T-t2" class="headerlink" title="1、public void arr(T t1,T t2){"></a>1、public<t>void arr(T t1,T t2){</t></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ttemp = t1;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1= t2;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2= temp;</p><p>}</p><h3 id="2、泛型：安全的，避免了数据类型转换的风险"><a href="#2、泛型：安全的，避免了数据类型转换的风险" class="headerlink" title="2、泛型：安全的，避免了数据类型转换的风险"></a>2、泛型：安全的，避免了数据类型转换的风险</h3><h3 id="3、泛型约束：entends：如果有多个约束则使用-amp-连接，约束只能有一个类，可以有多个接口"><a href="#3、泛型约束：entends：如果有多个约束则使用-amp-连接，约束只能有一个类，可以有多个接口" class="headerlink" title="3、泛型约束：entends：如果有多个约束则使用&amp;连接，约束只能有一个类，可以有多个接口"></a>3、泛型约束：entends：如果有多个约束则使用&amp;连接，约束只能有一个类，可以有多个接口</h3><h3 id="4、通配符？"><a href="#4、通配符？" class="headerlink" title="4、通配符？"></a>4、通配符？</h3><p>&nbsp;&nbsp;&nbsp; 上届通配符：？ extends A：表示A或者A的子类</p><p>&nbsp;&nbsp;&nbsp; 下届通配符：？ super A：表示A或者A的父类类型</p><p>&nbsp;&nbsp;&nbsp; List<string>list = new ArrayList<string>();</string></string></p><p>&nbsp;&nbsp;&nbsp; List&lt;?extends Object&gt; listobj = list;//成立</p><p>&nbsp;&nbsp;&nbsp; List<object>listobj = list;//不成立 在泛型中<string>和<object>是同级关系<p></p><p>&nbsp;</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Filefile1 =new File(“D:\a.txt”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File file2 =new File(“d:\UI”,”a.txt”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File file3 = new File(“D:\UI”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Filefile4 =new File(file3,”a.txt”);</p><h3 id="2、mkdirs-创建多层文件夹"><a href="#2、mkdirs-创建多层文件夹" class="headerlink" title="2、mkdirs()创建多层文件夹"></a>2、mkdirs()创建多层文件夹</h3><p>&nbsp;&nbsp;&nbsp; File file5 = new File(“D:\UI\aaa”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!file5.exists()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file5.mkdirs();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><h3 id="3、getAbsolutePath-打印文件路径"><a href="#3、getAbsolutePath-打印文件路径" class="headerlink" title="3、getAbsolutePath()打印文件路径"></a>3、getAbsolutePath()打印文件路径</h3><p>&nbsp; &nbsp;getPath()打印文件路径</p><p>&nbsp;&nbsp;&nbsp; System.out.println(file5.getAbsolutePath());//D:\UI\aaa</p><h3 id="4、getName-获取文件名-aaa"><a href="#4、getName-获取文件名-aaa" class="headerlink" title="4、getName()()获取文件名//aaa"></a>4、getName()()获取文件名//aaa</h3><h3 id="5、getParent-获取文件目录，不包含文件名-D-UI"><a href="#5、getParent-获取文件目录，不包含文件名-D-UI" class="headerlink" title="5、getParent()获取文件目录，不包含文件名//D:\UI"></a>5、getParent()获取文件目录，不包含文件名//D:\UI</h3><h3 id="6、isHidden-文件是否被隐藏-false"><a href="#6、isHidden-文件是否被隐藏-false" class="headerlink" title="6、isHidden()文件是否被隐藏//false"></a>6、isHidden()文件是否被隐藏//false</h3><h3 id="7、isDirectory-判断是否是文件夹-true"><a href="#7、isDirectory-判断是否是文件夹-true" class="headerlink" title="7、isDirectory()判断是否是文件夹//true"></a>7、isDirectory()判断是否是文件夹//true</h3><h3 id="8、isFile-判断是否是文件"><a href="#8、isFile-判断是否是文件" class="headerlink" title="8、isFile() 判断是否是文件"></a>8、isFile() 判断是否是文件</h3><h3 id="9、exists-判断是否存在"><a href="#9、exists-判断是否存在" class="headerlink" title="9、exists() 判断是否存在"></a>9、exists() 判断是否存在</h3><h3 id="10、newDate-file5-lastModified-获取最后一次修改的日期"><a href="#10、newDate-file5-lastModified-获取最后一次修改的日期" class="headerlink" title="10、newDate(file5.lastModified()) 获取最后一次修改的日期"></a>10、newDate(file5.lastModified()) 获取最后一次修改的日期</h3><h3 id="11、length-文件的字节数"><a href="#11、length-文件的字节数" class="headerlink" title="11、length() 文件的字节数"></a>11、length() 文件的字节数</h3><h3 id="12、file5-list-文件名的遍历"><a href="#12、file5-list-文件名的遍历" class="headerlink" title="12、file5.list() 文件名的遍历"></a>12、file5.list() 文件名的遍历</h3><p>&nbsp; String[]str =file5.list();</p><p>&nbsp; for(String s :str){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(s);</p><p>&nbsp;&nbsp;&nbsp; }// 3.doc</p><p>5.FEM</p><p>e.txt</p><h3 id="13、file5-listFiles-文件的遍历"><a href="#13、file5-listFiles-文件的遍历" class="headerlink" title="13、file5.listFiles() 文件的遍历"></a>13、file5.listFiles() 文件的遍历</h3><p>&nbsp;&nbsp;&nbsp; File[]files = file5.listFiles();&nbsp;&nbsp;</p><p>for(File f :files){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(f.isFile()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“文件”+f.getName()+”\t”+new Date(f.lastModified()));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }else{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(“文件夹”+f.getName());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }//文件3.docFri Feb 24 10:33:28 CST2017</p><p>文件5.FEM&nbsp;&nbsp; Fri Feb 24 10:33:37 CST 2017</p><p>文件e.txt&nbsp;&nbsp; Fri Feb 24 10:33:32 CST 2017</p><h3 id="14、File-listRoots-盘符的遍历"><a href="#14、File-listRoots-盘符的遍历" class="headerlink" title="14、File.listRoots(); 盘符的遍历"></a>14、File.listRoots(); 盘符的遍历</h3><p>&nbsp;&nbsp;&nbsp; File[] f1 = File.listRoots();</p><p>&nbsp;&nbsp;&nbsp; for(Filef :f1){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(f.toString());</p><p>&nbsp;&nbsp;&nbsp; }// C:\</p><p>D:\</p><p>&nbsp;</p><h2 id="文件IO流"><a href="#文件IO流" class="headerlink" title="文件IO流"></a>文件IO流</h2><h3 id="1、-字节流"><a href="#1、-字节流" class="headerlink" title="1、 字节流"></a>1、 字节流</h3><p>FileInputStream&nbsp;输入流 读文件</p><p>BufferedInputStream输入流读文件</p><p>&nbsp;</p><p>FileOutputStream输出流写入文件</p><p>BufferedOutputStream输出流写入文件</p><h3 id="2、字符流"><a href="#2、字符流" class="headerlink" title="2、字符流"></a>2、字符流</h3><p>FileReader输入流读文件</p><p>DataInputStream输入流 读文件</p><p>&nbsp;</p><p>FileWriter输出流 写入文件</p><p>DataOutputStream输出流 写入文件</p><p>&nbsp;</p><h3 id="3、FileInputStream-读取英文文件"><a href="#3、FileInputStream-读取英文文件" class="headerlink" title="3、FileInputStream 读取英文文件"></a>3、FileInputStream 读取英文文件</h3><p>&nbsp;&nbsp;&nbsp; FileInputStreamfis = new FileInputStream(“D:\UI\bbb.txt”);</p><p>&nbsp;&nbsp;&nbsp; intch = 0;</p><p>&nbsp;&nbsp;&nbsp; while((ch= fis.read()) != -1){ //read从此输入流中读取一个数据字节，返回值为int</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print((char)ch);</p><p>&nbsp;&nbsp;&nbsp; }</p><p>fis.close();//此程序不能读中文</p><h3 id="4、FileInputStream-读取中文文件"><a href="#4、FileInputStream-读取中文文件" class="headerlink" title="4、FileInputStream 读取中文文件"></a>4、FileInputStream 读取中文文件</h3><p>&nbsp;&nbsp;&nbsp; FileInputStreamfis = new FileInputStream(“D:\UI\bbb.txt”);</p><p>&nbsp;&nbsp;&nbsp; byte[]bt = new byte[1024]; //将字节读入字节数组</p><p>&nbsp;&nbsp;&nbsp; intlen = 0;</p><p>&nbsp;&nbsp;&nbsp; while((len= fis.read(bt))!=-1){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print(newString(bt,0,len));</p><p>&nbsp;&nbsp;&nbsp; }</p><h3 id="5、FileOutputStream-写入文件"><a href="#5、FileOutputStream-写入文件" class="headerlink" title="5、FileOutputStream 写入文件"></a>5、FileOutputStream 写入文件</h3><p>&nbsp;&nbsp;&nbsp; //搭建管道</p><p>FileOutputStream fos = new FileOutputStream(“D:\UI\bbb.txt”);</p><p>&nbsp;&nbsp;&nbsp; //读写操作</p><p>&nbsp;&nbsp;&nbsp; fos.write(98);//相当于b</p><p>&nbsp;&nbsp;&nbsp; fos.write(‘a’);</p><p>&nbsp;&nbsp;&nbsp; String str = “ssdsdfsf”;&nbsp;&nbsp;&nbsp; //写入字符串</p><p>&nbsp;&nbsp;&nbsp; byte[] b = str.getBytes();</p><p>&nbsp;&nbsp;&nbsp; fos.write(b);</p><p>&nbsp;&nbsp;&nbsp; fos.flush();//强制性的刷新缓冲区</p><p>&nbsp;&nbsp;&nbsp; //关闭流</p><p>&nbsp;&nbsp;&nbsp; if(fos !=null){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fos.close();</p><p>&nbsp;&nbsp;&nbsp; }</p><h3 id="6、DataOutputStream-写入boolean、double等类型的文件"><a href="#6、DataOutputStream-写入boolean、double等类型的文件" class="headerlink" title="6、DataOutputStream 写入boolean、double等类型的文件"></a>6、DataOutputStream 写入boolean、double等类型的文件</h3><p>&nbsp;&nbsp;&nbsp; FileOutputStream fos = null;</p><p>&nbsp;&nbsp;&nbsp; DataOutputStream dos = null;</p><p>&nbsp;&nbsp;&nbsp; fos =new FileOutputStream(“D:\UI\bbb.txt”);</p><p>&nbsp;&nbsp;&nbsp; dos =new DataOutputStream(fos);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; dos.writeBoolean(true);</p><p>&nbsp;&nbsp;&nbsp; dos.write(‘a’);</p><p>&nbsp;&nbsp;&nbsp; dos.writeDouble(12.34);</p><p>&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;10;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doubled = Math.random();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dos.writeDouble(d);</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; dos.flush();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; dos.close();</p><p>&nbsp;&nbsp;&nbsp; fos.close();</p><h3 id="7、DataInputStream读取boolean、double等类型的文件"><a href="#7、DataInputStream读取boolean、double等类型的文件" class="headerlink" title="7、DataInputStream读取boolean、double等类型的文件"></a>7、DataInputStream读取boolean、double等类型的文件</h3><p>&nbsp;&nbsp;&nbsp; FileInputStream fis =null;</p><p>&nbsp;&nbsp;&nbsp; DataInputStream dis = null;</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; fis =new FileInputStream(“D:\UI\bbb.txt”);</p><p>&nbsp;&nbsp;&nbsp; dis =new DataInputStream(fis);</p><p>&nbsp;&nbsp;&nbsp; booleanbool =dis.readBoolean();</p><p>&nbsp;&nbsp;&nbsp; System.out.println(bool);// true</p><p>&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;10;i++){</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; doubleb =dis.readDouble();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(b+”\t”);</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; dis.close();</p><p>&nbsp;&nbsp;&nbsp; fis.close();</p><p>&nbsp;&nbsp;&nbsp; // -6.414939283240485E-86&nbsp;&nbsp;</p><p>4.7384486223731214E285&nbsp;</p><p>7.602269187305488E-298&nbsp;</p><p>-1.4027415471626017E-278&nbsp;&nbsp;&nbsp;</p><p>9.32553721042958E-38&nbsp;&nbsp;&nbsp;</p><p>-1.0852988920338364E40&nbsp;</p><p>4.6544251087746895E49&nbsp;&nbsp;</p><p>1.0777059597027002E40&nbsp;&nbsp;</p><p>4.954807472569955E232&nbsp;&nbsp;</p><p>4.957881657894938E232&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><h3 id="8、序列化和反序列化"><a href="#8、序列化和反序列化" class="headerlink" title="8、序列化和反序列化"></a>8、序列化和反序列化</h3><p>&nbsp;&nbsp;&nbsp; 序列化：将对象的数据存储到文件 ObjectOutputStream</p><p>&nbsp;&nbsp;&nbsp; 反序列化：将文件中的数据重新读到对象 ObjectInputStream</p><p>&nbsp;&nbsp;&nbsp; 例题：在程序中创建一个Student类型的对象，并把对象信息保存到d:\io\student.txt文件中，然后再从文件中把Student对象的信息读出显示在控制台上。</p><p>&nbsp;&nbsp;&nbsp; //先建立Student类</p><p>publicclassStudentimplementsSerializable {//编写一个可序列化的类&nbsp; implements Serializable</p><p>&nbsp;&nbsp;&nbsp; privateintid;</p><p>&nbsp;&nbsp;&nbsp; private String name;</p><p>&nbsp;&nbsp;&nbsp; private String birth;</p><p>&nbsp;&nbsp;&nbsp; public Student(intid, Stringname, String birth) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.id = id;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.name = name;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.birth = birth;</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; @Override</p><p>&nbsp;&nbsp;&nbsp; public String toString() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; returnid+””+name+” “+birth;</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>//再进行序列化，即将Student对象写入文件，直接抛出异常范例</p><p>publicclass SObjectOutputStreamTest throws IOException{</p><p>&nbsp;&nbsp;&nbsp; publicstaticvoid main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Students1 = new Student(1,”we”,”1987-3-4”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Students2 = new Student(2,”you”,”1988-3-9”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileOutputStreamfos = null;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectOutputStreamoos = null;</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fos = new FileOutputStream(“D:\io\student.txt”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oos = new ObjectOutputStream(fos);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oos.writeObject(s1);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oos.writeObject(s2);</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; oos.close();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fos.close();</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>//进行反序列化，将文件中的语句读出到控制台，用try catch抓住异常范例</p><p>publicclass SObjectInputStreamTest {</p><p>&nbsp;&nbsp;&nbsp; publicstaticvoid main(String[]args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileInputStream fis = null;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectInputStream ois = null;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fis =new FileInputStream(“D:\io\student.txt”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ois =new ObjectInputStream(fis);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student s1 = (Student)ois.readObject();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student s2 = (Student)ois.readObject();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s1.toString());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s2.toString());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (FileNotFoundException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (IOException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }catch (ClassNotFoundException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }finally{</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ois!=null){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ois.close();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }catch (IOException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(fis!=null){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fis.close();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch (IOException e) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>&nbsp;</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、-进程：一个应用程序的一次运行，包含多线程"><a href="#1、-进程：一个应用程序的一次运行，包含多线程" class="headerlink" title="1、 进程：一个应用程序的一次运行，包含多线程"></a>1、 进程：一个应用程序的一次运行，包含多线程</h3><p>多线程：一个应用程序运行过程中的某些独立的片段</p><h3 id="2、-进程与线程的区别（优缺点）"><a href="#2、-进程与线程的区别（优缺点）" class="headerlink" title="2、 进程与线程的区别（优缺点）"></a>2、 进程与线程的区别（优缺点）</h3><p>进程：进程间切换耗费系统资源，数据安全（独立的代码和数据空间）</p><p>线程：线程间切换系统耗费比较小，数据不安全（共享代码和数据空间）</p><h3 id="3、-编写线程（掌握）"><a href="#3、-编写线程（掌握）" class="headerlink" title="3、 编写线程（掌握）"></a>3、 编写线程（掌握）</h3><p>a． 继承Thread类</p><p>publicclass ThreadTest1 {</p><p>publicstaticvoid main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ThreadDemotd = new ThreadDemo();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; td.start();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;1000;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“the main is:”+i);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>&nbsp;&nbsp;&nbsp; }</p><p>publicclass ThreadDemoextends Thread {</p><p>&nbsp;&nbsp;&nbsp; @Override</p><p>&nbsp;&nbsp;&nbsp; publicvoid run() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;1000;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“the run is:”+i);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>b． 实现Runnable接口（推荐，因为java类和类是单继承的）</p><p>publicclass RunnableTest {</p><p>&nbsp;&nbsp;&nbsp; publicstaticvoid main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RunnableDemord = new RunnableDemo();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Threadthread = new Thread(rd);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.start();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;1000;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“the main is:”+i);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(500);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>&nbsp;</p><p>publicclass RunnableDemoimplementsRunnable{</p><p>&nbsp;&nbsp;&nbsp; @Override</p><p>&nbsp;&nbsp;&nbsp; publicvoid run() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(inti=0;i&lt;1000;i++){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(“the run is:”+i);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(500);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><h3 id="4、CPU调度"><a href="#4、CPU调度" class="headerlink" title="4、CPU调度"></a>4、CPU调度</h3><p>&nbsp;&nbsp;&nbsp; 抢占式</p><p>&nbsp;&nbsp;&nbsp; 轮时间片</p><h3 id="5、让线程从运行状态进入到阻塞状态"><a href="#5、让线程从运行状态进入到阻塞状态" class="headerlink" title="5、让线程从运行状态进入到阻塞状态"></a>5、让线程从运行状态进入到阻塞状态</h3><p>Thread.yield();//暂停</p><p>Thread.sleep(500);//休眠</p><p>join();//在A线程中加入B线程，待B线程运行完后，再运行A线程</p><h3 id="6、线程其他方法"><a href="#6、线程其他方法" class="headerlink" title="6、线程其他方法"></a>6、线程其他方法</h3><p>&nbsp;&nbsp;&nbsp; setName（）：给线程起名字，默认的名字Thread-X；x从0开始</p><p>getName（）：得到线程的名字</p><p>Thread.currentThread().getName()：得到当前运行线程的名字</p><p>&nbsp;&nbsp;&nbsp; setPriority();设置线程的优先级数值</p><p>getPriority();获得线程的优先级数值</p><p>setDaemon(true);设置为守护线程</p><h3 id="7、用户线程和守护线程的区别"><a href="#7、用户线程和守护线程的区别" class="headerlink" title="7、用户线程和守护线程的区别"></a>7、用户线程和守护线程的区别</h3><p>&nbsp;&nbsp;&nbsp; 用户线程（前台线程）：必须执行完毕</p><p>&nbsp;&nbsp;&nbsp; 守护线程（精灵线程、后台线程）：线程体执行完毕也可，执行不完毕也可以，例如垃圾回收</p><h3 id="8、线程同步："><a href="#8、线程同步：" class="headerlink" title="8、线程同步："></a>8、线程同步：</h3><p>&nbsp;&nbsp;&nbsp; 加锁同步：一个对象只能有一把锁</p><p>&nbsp;&nbsp;&nbsp; 语句加锁 synchronized（对象）{}：可以对本类对象（this）和其他类对象（new 类）加锁；某个方法中的某些句子加锁，无法得知哪些方法是被synchronized保护的</p><p>&nbsp;&nbsp;&nbsp; 方法加锁 synchronized void methodA（）{}：只能对本类对象加锁；整个方法的所有语句加锁；可以显示得知方法是被synchronized保护的</p><h3 id="9、死锁：两个线程，彼此在等待对方占据的锁"><a href="#9、死锁：两个线程，彼此在等待对方占据的锁" class="headerlink" title="9、死锁：两个线程，彼此在等待对方占据的锁"></a>9、死锁：两个线程，彼此在等待对方占据的锁</h3><p>&nbsp;&nbsp;&nbsp; 锁的几种归还方式：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a．基本上执行完同步的程序代码后，锁会自动归还</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b．用break语句跳出同步的语句块，不过这对于写在方法声明的synchronized没有作用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c．遇到return语句</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d．遇到了异常</p><h3 id="10、线程的生命周期"><a href="#10、线程的生命周期" class="headerlink" title="10、线程的生命周期"></a>10、线程的生命周期</h3><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;</p><h2 id="网络编程（java-net）"><a href="#网络编程（java-net）" class="headerlink" title="网络编程（java.net）"></a>网络编程（java.net）</h2><h3 id="1、七层协议："><a href="#1、七层协议：" class="headerlink" title="1、七层协议："></a>1、七层协议：</h3><p>&nbsp;&nbsp;&nbsp;</p><h3 id="2、两台电脑之间的通信"><a href="#2、两台电脑之间的通信" class="headerlink" title="2、两台电脑之间的通信"></a>2、两台电脑之间的通信</h3><p>&nbsp;&nbsp;&nbsp; ip：ipv4（32位）、ipv6（128位）</p><p>&nbsp;&nbsp;&nbsp; 端口:1521（oracle）、8080（Tomcat默认的端口）、21（ftp）、80（默认的）</p><p>&nbsp;&nbsp;&nbsp; 协议：</p><p>UDP：传输层，用户数据的协议，无连接的协议，不可靠的，不能够准确到达，效率比较高，适用于数据量比较大并且允许出错的，比如网络视频</p><p>TCP/IP:传输层 ，有连接的协议，可靠的、准确的到达，效率比较低</p><p>http：https：ftp等在应用层</p><p>&nbsp;&nbsp;&nbsp; http协议：明文无状态的</p><p>&nbsp;&nbsp;&nbsp; https：密文</p><h3 id="3、客户端和服务器端"><a href="#3、客户端和服务器端" class="headerlink" title="3、客户端和服务器端"></a>3、客户端和服务器端</h3><p>&nbsp;&nbsp;&nbsp; 基于UDP的</p><p>客户端：</p><p>Socket client = new Socket(“10.25.116.222”,8088);</p><p>&nbsp;&nbsp;&nbsp; 服务器端：&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServerSocketserver =ServerSocket(8088);ji</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket s =server.accept();</p><h3 id="4、-端口号范围是0-65535，用户普通网络程序用1024以上"><a href="#4、-端口号范围是0-65535，用户普通网络程序用1024以上" class="headerlink" title="4、 端口号范围是0-65535，用户普通网络程序用1024以上"></a>4、 端口号范围是0-65535，用户普通网络程序用1024以上</h3><h3 id="5、-InetAddress此类表示互联网协议ip地址"><a href="#5、-InetAddress此类表示互联网协议ip地址" class="headerlink" title="5、 InetAddress此类表示互联网协议ip地址"></a>5、 InetAddress此类表示互联网协议ip地址</h3><p>InetAddress address = InetAddress.getByName(“主机名”);</p><h3 id="6、getHostName（）获取此IP地址的主机名"><a href="#6、getHostName（）获取此IP地址的主机名" class="headerlink" title="6、getHostName（）获取此IP地址的主机名"></a>6、getHostName（）获取此IP地址的主机名</h3><p>getHostAddress（）获取IP地址字符串</p><p>getByName()通过主机名获取ip地址</p><p>getLocalPort()获取本程序所用接口</p><p>&nbsp;</p><h2 id="JAVA7新特性"><a href="#JAVA7新特性" class="headerlink" title="JAVA7新特性"></a>JAVA7新特性</h2><h3 id="1、数值型的数据赋值可以使用下划线-增加可读性"><a href="#1、数值型的数据赋值可以使用下划线-增加可读性" class="headerlink" title="1、数值型的数据赋值可以使用下划线_ 增加可读性"></a>1、数值型的数据赋值可以使用下划线_ 增加可读性</h3><p>&nbsp;&nbsp;&nbsp; 不能写在小数点后;</p><p>&nbsp;&nbsp;&nbsp; 不能在数值型数据的开始</p><p>不能在数值型数据的最后添加</p><p>Doublepi = 3.1415_9265</p><p>Intbillion = 1_000_000_000</p><h3 id="2、-可以声明n进制数据"><a href="#2、-可以声明n进制数据" class="headerlink" title="2、 可以声明n进制数据"></a>2、 可以声明n进制数据</h3><p>Int i1= 0b0100;//4二进制前方放0b</p><p>Inti2 = 07; //7八进制前方放0</p><p>Inti3 = 0x00ad;//十六进制前方放0x</p><h3 id="3、switch-表达式："><a href="#3、switch-表达式：" class="headerlink" title="3、switch:表达式："></a>3、switch:表达式：</h3><p>&nbsp;&nbsp;&nbsp;jdk1.7以下byte、short、char、int；</p><p>jdk1.7以上在上面基础上加上String</p><h3 id="4、try（IO流）"><a href="#4、try（IO流）" class="headerlink" title="4、try（IO流）{"></a>4、try（IO流）{</h3><p>Stringstr=br.readLine();</p><p>}catch (ArithmeticException | IOException e) {//catch里可以有多个异常类，不能是父子关系</p><p>&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();</p><p>}//不用关闭流了，自动资源管理器</p><h3 id="5、泛型"><a href="#5、泛型" class="headerlink" title="5、泛型"></a>5、泛型</h3><p>&nbsp;&nbsp;&nbsp; List<string>list = new List<string>();//jdk1.7以下</string></string></p><p>&nbsp;&nbsp;&nbsp; List<string>list = new List&lt; &gt;();&nbsp; //jdk1.7以上</string></p><h3 id="6、新加G1垃圾回收器-提高效率"><a href="#6、新加G1垃圾回收器-提高效率" class="headerlink" title="6、新加G1垃圾回收器 提高效率"></a>6、新加G1垃圾回收器 提高效率</h3><h3 id="7、NIO2"><a href="#7、NIO2" class="headerlink" title="7、NIO2"></a>7、NIO2</h3><p>&nbsp;&nbsp;&nbsp; Files.copy(Paths.get(文件一),Paths.get(文件二));//直接复制文件</p><p>&nbsp;&nbsp;&nbsp; File.createFile();//创建新文件</p><p>&nbsp;&nbsp;&nbsp; File.move();//移动</p><p>&nbsp;&nbsp;&nbsp; File.delete();</p><p>&nbsp;&nbsp;&nbsp; //用WatchService类型实现文件监控</p><p>&nbsp;&nbsp;&nbsp; WatchServicewatchService = FileSystems.getDefault().newWatchService();</p><p>&nbsp;</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="1、编写jdbc程序的步骤："><a href="#1、编写jdbc程序的步骤：" class="headerlink" title="1、编写jdbc程序的步骤："></a>1、编写jdbc程序的步骤：</h3><p>&nbsp;&nbsp; 1）添加数据库的驱动jar包&nbsp;ojbc5.jar或者ojdbc6.jar或者classes12.jar</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 工程名右击—Build Path—Add External Archives—数据库安装路径—jdbc-ojdbc6.jar</p><p>&nbsp;&nbsp; 2）创建驱动类对象&nbsp; OracleDriver对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //创建反射机制</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class.forName(“oracle.jdbc.driver.OracleDriver”);</p><p>&nbsp;&nbsp; 3）连接数据库&nbsp; Connection</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stringutl = “jdbc:oracle:thin:@YLMF123-3131857:1521:orcl”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stringuser = “scott”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stringpassword = “tiger”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Connectionconn = DriverManager.getConnection(url,user,password);</p><p>&nbsp;&nbsp; 4）操作数据库&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //第一种方法Statement会引起注入，不推荐使用</p><p>String sql = “select deptno,dname,loc from dept”;</p><p>Statement stmt = conn.createStatement();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultSet rs =stmt.executeQuery(sql);//发送sql语句到数据库，然后将查询到的结果返回到ResultSet</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //int I = stmt.executeUpdate(sql);//查询影响的行数</p><p>while(rs.next()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intdeptno =rs.getInt(1);//列的索引从1开始计</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String dname =rs.getString(2);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String loc =rs.getString(3);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(deptno+”\t”+dname+”\t”+loc);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //第二种方法PreparedStatement防止注入 推荐使用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String sql = “insert into dept(deptno,dname,loc) values(?,?,?)”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt = conn.prepareStatement(sql);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intdeptno = 35;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String dname = “sdfs”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String loc = “北京”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt.setInt(1, deptno);//第一个问号放deptno</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt.setString(2, dname);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt.setString(3, loc);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt.executeUpdate();//执行删除、插入、修改语句，executeQuery执行查询语句</p><p>5）关闭数据库</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rs.close();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stmt.close();</p><p>&nbsp;&nbsp;&nbsp; conn.close();</p><h3 id="2、批处理："><a href="#2、批处理：" class="headerlink" title="2、批处理："></a>2、批处理：</h3><p>&nbsp;&nbsp; stmt.addBatch(sql1);</p><p>&nbsp;&nbsp;&nbsp; stmt.addBatch(sql2);//可以执行多句sql语句</p><p>&nbsp;&nbsp; executeBatch();//执行</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String sql=”insert intodept(deptno,dname,loc) values(?,?,?)”;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt=conn.prepareStatement(sql);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstmt.setInt(1, 51);</p><p>&nbsp;&nbsp;&nbsp; pstmt.setString(2, “电信部”);</p><p>&nbsp;&nbsp;&nbsp; pstmt.setString(3, “上海”);</p><p>&nbsp;&nbsp;&nbsp; pstmt.addBatch();</p><p>&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp; pstmt.setInt(1, 52);</p><p>&nbsp;&nbsp;&nbsp; pstmt.setString(2, “实施部”);</p><p>&nbsp;&nbsp;&nbsp; pstmt.setString(3, “广州”);</p><p>&nbsp;&nbsp;&nbsp; pstmt.addBatch();</p><p>&nbsp;</p><p>pstmt.executeBatch();</p><h3 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h3><p>&nbsp;&nbsp;&nbsp; conn.setAutoCommit（false）：设